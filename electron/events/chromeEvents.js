import { ipcMain } from "electron";
import { exec } from "child_process";
import puppeteer from "puppeteer-core";
// H√†m l·∫•y danh s√°ch PID c·ªßa Chrome
function getChromeRunnings() {
  return new Promise((resolve, reject) => {
    exec('tasklist /FI "IMAGENAME eq chrome.exe" /V', (err, stdout) => {
      if (err) {
        reject(`L·ªói l·∫•y danh s√°ch Chrome: ${err.message}`);
        return;
      }

      let result = stdout
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => {
          return (
            line.includes("- Google Chrome") || line.includes("- GPM-Browser")
          );
        })
        .map((line) => {
          const parts = line.split(/\s+/);
          let profileName = `noname_${parts[1]}`;
          if (line.includes("- GPM-Browser")) {
            const regex = /\d{1,2}:\d{2}:\d{2} (.+?)\s*-/;
            const match = line.match(regex);
            profileName = match ? match[1].trim() : `noname_${parts[1]}`;
          }
          return {
            pid: parts[1],
            profileName: profileName
          };
        });

      resolve(result);
    });
  });
}

// H√†m ki·ªÉm tra PID c√≥ m·ªü c·ªïng kh√¥ng
function getPortsForPID(pid) {
  return new Promise((resolve, reject) => {
    exec(`netstat -ano | findstr LISTENING | findstr ${pid}`, (err, stdout) => {
      if (err) {
        resolve(false); // N·∫øu l·ªói th√¨ gi·∫£ ƒë·ªãnh kh√¥ng c√≥ port n√†o
        return;
      }

      let ports = stdout
        .split("\n")
        .map((line) => line.trim())
        .filter((line) => line.includes("TCP") || line.includes("UDP"))
        .map((line) => {
          const parts = line.split(/\s+/);

          return {
            protocol: parts[0],
            localAddress: parts[1],
            pid: parts[parts.length - 1]
          };
        });

      resolve(ports?.[0] ?? false);
    });
  });
}

ipcMain.on("get-chrome-profiles", async (event) => {
  try {
    const profilerunnings = await getChromeRunnings();
    let results = [];

    for (const profile of profilerunnings) {
      const remoteIP = await getPortsForPID(profile.pid);
      if (remoteIP?.localAddress) {
        results.push({
          ...profile,
          remoteIP: remoteIP?.localAddress
        });
      }
    }
    event.reply("chrome-profiles", results);
  } catch (error) {
    return `L·ªói: ${error}`;
  }
});

const connectedBrowsers = {};

const connectBrowser = async (profileName, profileUrl) => {
  try {
    const browser = await puppeteer.connect({
      browserURL: `http://${profileUrl}`,
      defaultViewport: null
    });
    connectedBrowsers[profileName] = browser;
    console.log("Connected to browser:", profileUrl);
  } catch (error) {
    console.error("‚ùå Connect error:", error);
  }
};

const _newTab = async (profile) => {
  if (!connectedBrowsers[profile.profileName]) {
    await connectBrowser(profile.profileName, profile.remoteIP);
  }
  const browser = connectedBrowsers[profile.profileName];
  const page = await browser.newPage();
  await page.goto("chrome://newtab");
  console.log(`‚úÖ ƒê√£ m·ªü Google cho ${profile.profileName}`);
};

const newTab = async (selectedProfiles, isSerial = false, delay = false) => {
  if (isSerial) {
    for (const profile of selectedProfiles) {
      await _newTab(profile);
      if (delay) await new Promise((r) => setTimeout(r, delay * 1000));
    }
    return;
  } else {
    selectedProfiles.forEach(async (profile) => {
      _newTab(profile);
    });
    return;
  }
};

const _closeTab = async (profile) => {
  if (!connectedBrowsers[profile.profileName]) {
    await connectBrowser(profile.profileName, profile.remoteIP);
  }
  const browser = connectedBrowsers[profile.profileName];

  const pages = await browser.pages(); // L·∫•y t·∫•t c·∫£ tab
  console.log(`${profile.profileName} c√≥ ${pages.length} tab`);

  for (const page of pages) {
    try {
      await page.bringToFront(); // Chuy·ªÉn tab l√™n tr∆∞·ªõc
      await new Promise((r) => setTimeout(r, 500)); // Ch·ªù 0.5s ƒë·ªÉ tr√°nh l·ªói
      const isActive = await page.evaluate(
        () => document.visibilityState === "visible"
      ); // Ki·ªÉm tra tab ƒëang hi·ªán

      if (isActive) {
        await page.close();
        console.log(`‚úÖ ƒê√£ ƒë√≥ng tab active c·ªßa ${profile.profileName}`);
        break;
      }
    } catch (error) {
      console.error("‚ùå L·ªói khi ƒë√≥ng tab:", error);
    }
  }
};

const closeTab = async (selectedProfiles, isSerial = false, delay = false) => {
  if (isSerial) {
    for (const profile of selectedProfiles) {
      await _closeTab(profile);
      if (delay) await new Promise((r) => setTimeout(r, delay * 1000));
    }
    return;
  } else {
    selectedProfiles.forEach(async (profile) => {
      _closeTab(profile);
    });
    return;
  }
};

const _openUrl = async (profile, url, newTab = false) => {
  if (!connectedBrowsers[profile.profileName]) {
    await connectBrowser(profile.profileName, profile.remoteIP);
  }
  const browser = connectedBrowsers[profile.profileName];
  let page;

  if (newTab) {
    page = await browser.newPage(); // M·ªü tab m·ªõi n·∫øu newTab = true
    console.log("üÜï ƒê√£ m·ªü tab m·ªõi.");
  } else {
    const pages = await browser.pages();

    // Ki·ªÉm tra tab ƒëang active
    for (const p of pages) {
      const isActive = await p.evaluate(() => document.hasFocus());
      if (isActive) {
        page = p;
        break;
      }
    }

    if (!page) {
      console.log("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y tab active, d√πng tab cu·ªëi c√πng.");
      page = pages[pages.length - 1] || (await browser.newPage());
    }
  }

  await page.bringToFront(); // ƒê∆∞a tab l√™n tr∆∞·ªõc
  await page.goto(url, { waitUntil: "load" }); // ƒêi·ªÅu h∆∞·ªõng ƒë·∫øn URL
  console.log(
    `‚úÖ ƒê√£ m·ªü ${url} ${newTab ? "trong tab m·ªõi" : "trong tab hi·ªán t·∫°i"}`
  );
};

const openUrl = async (
  selectedProfiles,
  url,
  newTab = false,
  isSerial = false,
  delay = false
) => {
  if (isSerial) {
    for (const profile of selectedProfiles) {
      await _openUrl(profile, url, newTab);
      if (delay) await new Promise((r) => setTimeout(r, delay * 1000));
    }
    return;
  } else {
    selectedProfiles.forEach(async (profile) => {
      _openUrl(profile, url, newTab);
    });
    return;
  }
};

const _typing = async (
  profile,
  text,
  selectorType,
  selectorValue,
  pastingMode = true
) => {
  try {
    if (!connectedBrowsers[profile.profileName]) {
      await connectBrowser(profile.profileName, profile.remoteIP);
    }
    const browser = connectedBrowsers[profile.profileName];
    let page;

    const pages = await browser.pages();
    if (pages.length === 0) {
      console.error("‚ö†Ô∏è Kh√¥ng c√≥ tab n√†o m·ªü. M·ªü tab m·ªõi...");
      page = await browser.newPage();
    } else {
      for (const p of pages) {
        const isActive = await p.evaluate(() => document.hasFocus());
        if (isActive) {
          page = p;
          break;
        }
      }
      if (!page) page = pages[pages.length - 1]; // N·∫øu kh√¥ng t√¨m th·∫•y tab active, l·∫•y tab cu·ªëi c√πng
    }

    await page.bringToFront();

    // Ch·ªëng b·ªã ph√°t hi·ªán l√† bot
    await page.evaluateOnNewDocument(() => {
      Object.defineProperty(navigator, "webdriver", { get: () => false });
    });

    let elementHandle = null;

    // üîπ T√¨m ph·∫ßn t·ª≠ theo lo·∫°i selector
    switch (selectorType) {
      case "xpath":
        console.log(`üîç ƒêang t√¨m XPath: ${selectorValue}`);
        elementHandle = await page.evaluateHandle((xpath) => {
          const result = document.evaluate(
            xpath,
            document,
            null,
            XPathResult.FIRST_ORDERED_NODE_TYPE,
            null
          );
          return result.singleNodeValue;
        }, selectorValue);
        break;
      case "id":
        console.log(`üîç ƒêang t√¨m ID: ${selectorValue}`);
        elementHandle = await page.$(`#${selectorValue}`);
        break;
      case "name":
        console.log(`üîç ƒêang t√¨m Name: ${selectorValue}`);
        elementHandle = await page.$(`[name="${selectorValue}"]`);
        break;
      case "css":
        console.log(`üîç ƒêang t√¨m CSS Selector: ${selectorValue}`);
        elementHandle = await page.$(selectorValue);
        break;
      default:
        console.error(`‚ùå Lo·∫°i selector kh√¥ng h·ª£p l·ªá: ${selectorType}`);
        return;
    }

    if (!elementHandle) {
      console.error(
        `‚ùå Kh√¥ng t√¨m th·∫•y ph·∫ßn t·ª≠: ${selectorType} = "${selectorValue}"`
      );
      return;
    }

    // M√¥ ph·ªèng di chu·ªôt tr∆∞·ªõc khi click
    const box = await elementHandle.boundingBox();
    if (box) {
      await page.mouse.move(
        box.x + box.width / 2 + Math.random() * 5,
        box.y + box.height / 2 + Math.random() * 5
      );
      await new Promise((resolve) =>
        setTimeout(resolve, Math.random() * 300 + 200)
      );
    }

    // Click v√†o input tr∆∞·ªõc khi nh·∫≠p
    await elementHandle.click({
      clickCount: 3,
      delay: Math.random() * 100 + 50
    }); // Ch·ªçn to√†n b·ªô n·ªôi dung
    await page.keyboard.press("Backspace"); // X√≥a s·∫°ch n·ªôi dung hi·ªán t·∫°i

    await new Promise((resolve) =>
      setTimeout(resolve, Math.random() * 300 + 200)
    );

    if (pastingMode) {
      // üìù D√°n n·ªôi dung tr·ª±c ti·∫øp b·∫±ng evaluate()
      console.log(
        `üìã Paste "${text}" v√†o ${selectorType} = "${selectorValue}"`
      );
      await page.evaluate(
        (el, value) => {
          el.value = value;
          el.dispatchEvent(new Event("input", { bubbles: true }));
        },
        elementHandle,
        text
      );
    } else {
      // ‚å®Ô∏è G√µ t·ª´ng k√Ω t·ª± (m·∫∑c ƒë·ªãnh)
      console.log(
        `‚å®Ô∏è Typing "${text}" v√†o ${selectorType} = "${selectorValue}"`
      );
      await elementHandle.type(text, { delay: Math.random() * 200 + 50 });
    }
  } catch (error) {
    console.error(
      `‚ùå L·ªói khi nh·∫≠p li·ªáu v√†o ${selectorType} = "${selectorValue}":`,
      error
    );
  }
};

const typing = async (
  selectedProfiles,
  text,
  targetSelector,
  targetValue,
  pastingMode = true,
  isSerial = false,
  delay = false
) => {
  let textValue = text;
  if (isSerial) {
    for (const profile of selectedProfiles) {
      if (typeof text === "object") {
        textValue = text?.[profile.profileName] ?? "";
      }
      await _typing(
        profile,
        textValue,
        targetSelector,
        targetValue,
        pastingMode
      );
      if (delay) await new Promise((r) => setTimeout(r, delay * 1000));
    }
    return;
  } else {
    selectedProfiles.forEach(async (profile) => {
      if (typeof text === "object") {
        textValue = text?.[profile.profileName] ?? "";
      }
      _typing(profile, textValue, targetSelector, targetValue, pastingMode);
    });
    return;
  }
};

ipcMain.on("actions", (event, data) => {
  const { action, actionData, doActionSerial, delayValue, selectedProfiles } =
    data;
  console.log(data);

  switch (action) {
    case "newtab":
      newTab(selectedProfiles, doActionSerial, delayValue);
      break;
    case "close_current_tab":
      closeTab(selectedProfiles);
      break;
    case "open_url":
      const url = actionData.url;
      const openInNewTab = actionData?.newTab || false;
      openUrl(selectedProfiles, url, openInNewTab, doActionSerial, delayValue);
      break;
    case "typing":
      const text = actionData.text;
      const targetSelector = actionData.targetSelector;
      const targetValue = actionData.targetValue;
      const pastingMode = actionData.pastingMode;
      typing(
        selectedProfiles,
        text,
        targetSelector,
        targetValue,
        pastingMode,
        doActionSerial,
        delayValue
      );
      break;
    default:
      console.log("Action default");
      break;
  }
});
